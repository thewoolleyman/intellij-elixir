{
  parserClass="org.elixir_lang.parser.ElixirParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  // direct children of matchedExpression
  extends("matched(AccessExpression|.*Operation|((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)Call|Qualified(Alias|MultipleAliases))")=matchedExpression
  // direct children of unmatchedExpression
  extends("unmatched(AccessExpression|.*Operation|((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)Call|Qualified(Alias|MultipleAliases))")=unmatchedExpression

  // name identifier owner calls - no argument calls are included because in a pipeline they can have effective arguments
  elementTypeFactory("((un)?matched((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)|unqualifiedNoParenthesesManyArguments)Call")="org.elixir_lang.ElementTypeFactory.factory"
  methods(           "((un)?matched((At)?Unqualified(No)?(Argument|Parenthese)s|Dot)|unqualifiedNoParenthesesManyArguments)Call")=[
    canonicalName
    canonicalNameSet
    functionName
    functionNameElement
    getDoBlock
    hasDoBlockOrKeyword
    getName
    getNameIdentifier
    getPresentation
    getReference
    getStub
    getUseScope
    isCalling
    isCallingMacro
    moduleName
    primaryArguments
    primaryArity
    processDeclarations
    quote
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    secondaryArguments
    secondaryArity
    setName
  ]

  // qualified calls that need to implement #qualifier()
  methods("(un)?matchedQualified(No)?(Argument|Parenthese)sCall")=[
    canonicalName
    canonicalNameSet
    functionName
    functionNameElement
    getDoBlock
    hasDoBlockOrKeyword
    getName
    getNameIdentifier
    getPresentation
    getReference
    getStub
    getUseScope
    isCalling
    isCallingMacro
    moduleName
    primaryArguments
    primaryArity
    processDeclarations
    qualifier
    quote
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    secondaryArguments
    secondaryArity
    setName
  ]

  // in operations that works as calls
  implements("(un)?matchedInOperation")=[
    "org.elixir_lang.psi.call.Call"
    "org.elixir_lang.psi.operation.In"
  ]
  // methods set by infix operations below

  /* infix operations that work as name identifier owner calls - specifically support getNameIdentifier so they can
     return their operator, so it is easy to use a different operator when making customer operators like in Bitwise or
     the free arrow operators */
  implements(        "(un)?matched(Comparison|Multiplication|Or|Relational)Operation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Infix"
  ]
  methods(           "(un)?matched(Addition|And|Arrow|Comparison|In|InMatch|Match|Multiplication|Or|Pipe|Relational|Three|Two|Type|When)Operation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    leftOperand
    moduleName
    operator
    primaryArguments
    primaryArity
    processDeclarations
    quote
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    rightOperand
    secondaryArguments
    secondaryArity
    setName
  ]

  implements("(un)?matchedAdditionOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Addition"
  ]
  // methods set by infix operations above

  implements("(un)?matchedAndOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.And"
  ]
  // methods set by infix operations above

  implements("(un)?matchedArrowOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Arrow"
  ]

  implements("(un)?matchedInMatchOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.InMatch"
  ]
  // methods set by infix operations above

  implements("(un)?matchedMatchOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Match"
  ]
  // methods set by infix operations above

  implements("(un)?matchedPipeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Pipe"
  ]
  // methods set by infix operations above

  implements("(un)?matchedThreeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Three"
  ]
  // methods set by infix operations above

  implements("(un)?matchedTwoOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Two"
  ]
  // methods set by infix operations above

  implements("(un)?matchedTypeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Type"
  ]
  // methods set by infix operations above

  implements("(un)?matchedWhenOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.When"
  ]
  // methods set by infix operations above

  /*
   * Prefix operations
   *
   * Have names (their operators), but aren't stubbed because they don't define structures.
   */
  implements(        "((at|capture|unary)Numeric|(un)?matched(Capture)NonNumeric)Operation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Prefix"
  ]
  methods(           "((at|capture|unary)Numeric|(un)?matched(Capture|Unary)NonNumeric)Operation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    moduleName
    operand
    operator
    primaryArguments
    primaryArity
    quote
    secondaryArguments
    secondaryArity
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    setName
  ]

  // atNonNumeric operations
  implements("(un)?matchedAtNonNumericOperation")=[
    "org.elixir_lang.psi.AtNonNumericOperation"
  ]
  methods("(un)?matchedAtNonNumericOperation")=[
    getReference
    moduleAttributeName
    operand
    operator
    quote
  ]

  // unaryNonNumeric operations
  implements("(un)?matchedUnaryNonNumericOperation")=[
    "org.elixir_lang.psi.UnaryNonNumericOperation"
  ]
  // method set by prefix operations above

  // QualifiedBracketOperation
  implements("(un)?matchedQualifiedBracketOperation")=[
    "org.elixir_lang.psi.QualifiedBracketOperation"
  ]
  methods(   "(un)?matchedQualifiedBracketOperation")=[
    qualifier
    quote
  ]

  // QualifiedMultipleAliases
  implements("(un)?matchedQualifiedMultipleAliases")=[
    "org.elixir_lang.psi.QualifiedMultipleAliases"
  ]
  methods(   "(un)?matchedQualifiedMultipleAliases")=[
    quote
  ]

  // Heredoc
  methods("(charList|string)Heredoc")=[
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getFragmentType
    getHeredocLineList
    quote
    quoteBinary
    quoteEmpty
    quoteLiteral
  ]

  // Quote
  methods("(charList|string)Line") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getBody
    getFragmentType
    quote
    quoteAsAtom
    quoteBinary
    quoteEmpty
    quoteLiteral
  ]

  // Sigil Heredoc
  methods("(interpolated|literal)((CharList|String)Sigil|Regex|Sigil|Words)Heredoc") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getFragmentType
    getHeredocLineList
    quote
    quoteBinary
    quoteEmpty
    quoteLiteral
    sigilName
  ]

  // Sigil Line
  methods("(interpolated|literal)((CharList|String)Sigil|Regex|Sigil|Words)Line") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getBody
    getFragmentType
    quote
    quoteBinary
    quoteEmpty
    quoteLiteral
    sigilName
    terminator
  ]

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"
  psiImplUtilClass="org.elixir_lang.psi.impl.ElixirPsiImplUtil"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    AFTER = "after"
    ALIAS_TOKEN = "Alias"
    AND_OPERATOR = "&&&, `and`, &&"
    ARROW_OPERATOR = "<<<, <<~, <|>, <~>, >>>, ~>>, <~, |>, ~>"
    ASSOCIATION_OPERATOR = "=>"
    ATOM_FRAGMENT = "A-Z, a-z, _, @, 0-9. ?, !"
    AT_OPERATOR = "@"
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    BIT_STRING_OPERATOR = "<<>>"
    CALL = "<zero-width-call>"
    CAPTURE_OPERATOR = "&"
    CATCH = "catch"
    CHAR_LIST_FRAGMENT = "Char List Fragment"
    CHAR_LIST_HEREDOC_PROMOTER = "Char List Heredoc Promoter (''')"
    CHAR_LIST_HEREDOC_TERMINATOR = "Char List Heredoc Terminator (''')"
    CHAR_LIST_PROMOTER = "Char List Promoter (')"
    CHAR_LIST_SIGIL_HEREDOC_PROMOTER = "Char List Sigil Heredoc Promoter (\"\"\", ''')"
    CHAR_LIST_SIGIL_HEREDOC_TERMINATOR = "Char List Sigil Heredoc Terminator (\"\"\", ''')"
    CHAR_LIST_SIGIL_PROMOTER = "Char List Sigil Promoter ({, [, <, \", /, (, |, ')"
    CHAR_LIST_SIGIL_TERMINATOR = "Char List Sigil Terminator ({, [, <, \", /, (, |, ')"
    CHAR_LIST_TERMINATOR = "Char List Terminator (')"
    CHAR_TOKENIZER = "?"
    CLOSING_BIT = ">>"
    CLOSING_BRACKET = "]"
    CLOSING_CURLY = "}"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COLON = ":"
    COMMA = ","
    COMMENT = "#"
    COMPARISON_OPERATOR = "!==, ===, !=, ==, =~"
    DECIMAL_MARK = "Decimal Mark (.)"
    DECIMAL_SEPARATOR = "_"
    DO = "do"
    DOT_OPERATOR = "."
    DUAL_OPERATOR = "+, -"
    ELSE = "else"
    EOL = "\\n, \\r\\n"
    END = "end"
    ESCAPE = "\\"
    ESCAPED_CHARACTER_TOKEN = "\\<character>, \\x{<hexadecimal-digit>}, \\x<hexadecimal-digit>, \\\\n, \\\\r\\n"
    EXPONENT_MARK = "E, e"
    FALSE = "false"
    FN = "fn"
    HEREDOC_LINE_WHITE_SPACE_TOKEN = "Whitespace at beginning of line of heredoc"
    HEREDOC_PREFIX_WHITE_SPACE = "Whitespace at beginning of last line of heredoc before terminator"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IDENTIFIER_TOKEN = "identifier"
    INTERPOLATING_CHAR_LIST_SIGIL_NAME = "c"
    INTERPOLATING_REGEX_SIGIL_NAME = "r"
    INTERPOLATING_SIGIL_NAME = "a-b, d-q, t-v, x-z"
    INTERPOLATING_STRING_SIGIL_NAME = "s"
    INTERPOLATING_WORDS_SIGIL_NAME = "w"
    // Can't be just "}", because that's used for the more general CLOSING_CURLY
    INTERPOLATION_END = "Interpolation End (})"
    // Human-readable "Interpolation Start" to match format of INTERPOLATION_END
    INTERPOLATION_START = "Interpolation Start (#{)"
    INVALID_BINARY_DIGITS = "A-Z, a-z, 2-9"
    INVALID_DECIMAL_DIGITS = "A-Z, a-z"
    INVALID_HEXADECIMAL_DIGITS = "G-Z, g-z"
    INVALID_OCTAL_DIGITS = "A-Z, a-z, 8-9"
    INVALID_UNKNOWN_BASE_DIGITS = "A-Z, a-z, 0-9"
    IN_MATCH_OPERATOR = "<-, \\\\"
    IN_OPERATOR = "in"
    KEYWORD_PAIR_COLON = "Keyword Pair Colon (:)"
    LITERAL_CHAR_LIST_SIGIL_NAME = "C"
    LITERAL_REGEX_SIGIL_NAME = "R"
    LITERAL_SIGIL_NAME = "A-B, D-Q, T-V, X-Z"
    LITERAL_STRING_SIGIL_NAME = "S"
    LITERAL_WORDS_SIGIL_NAME = "W"
    MAP_OPERATOR = "%{}"
    MATCH_OPERATOR = "="
    MULTIPLICATION_OPERATOR = "*, /"
    NIL = "nil"
    NOT_OPERATOR = "not"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BIT = "<<"
    OPENING_BRACKET = "["
    OPENING_CURLY = "{"
    OPENING_PARENTHESIS = "("
    OR_OPERATOR = "|||, `or`, ||"
    PIPE_OPERATOR = "|"
    REGEX_FRAGMENT = "Regex Fragment"
    REGEX_HEREDOC_PROMOTER = "Regex Heredoc Promoter (\"\"\", ''')"
    REGEX_HEREDOC_TERMINATOR = "Regex Heredoc Terminator (\"\"\", ''')"
    REGEX_PROMOTER = "Regex Promoter ({, [, <, \", /, (, |, ')"
    REGEX_TERMINATOR = "Regex Terminator ({, [, <, \", /, (, |, ')"
    RELATIONAL_OPERATOR = "<, <=, >=, >"
    RESCUE = "rescue"
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    SIGIL_FRAGMENT = "Sigil Fragment"
    SIGIL_HEREDOC_PROMOTER = "Sigil Heredoc Promoter (\"\"\", ''')"
    SIGIL_HEREDOC_TERMINATOR = "Sigil Heredoc Terminator (\"\"\", ''')"
    SIGIL_MODIFIER = "a-z"
    SIGIL_PROMOTER = "Sigil Promoter ({, [, <, \", /, (, |, ')"
    SIGIL_TERMINATOR = "Sigil Terminator ({, [, <, \", /, (, |, ')"
    SIGNIFICANT_WHITE_SPACE = "<significant-space>";
    STAB_OPERATOR = "->"
    STRING_FRAGMENT = "String Fragment"
    STRING_HEREDOC_PROMOTER = "String Heredoc Promoter (\"\"\")"
    STRING_HEREDOC_TERMINATOR = "String Heredoc Terminator (\"\"\")"
    STRING_PROMOTER = "String Promoter (\")"
    STRING_SIGIL_HEREDOC_PROMOTER = "String Sigil Heredoc Promoter (\"\"\", ''')"
    STRING_SIGIL_HEREDOC_TERMINATOR = "String Sigil Heredoc Terminator (\"\"\", ''')"
    STRING_SIGIL_PROMOTER = "String Sigil Promoter ({, [, <, \", /, (, |, ')"
    STRING_SIGIL_TERMINATOR = "String Sigil Terminator ({, [, <, \", /, (, |, ')"
    STRING_TERMINATOR = "String Terminator (\")"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    TILDE = "~"
    TRUE = "true"
    TUPLE_OPERATOR = "{}"
    TWO_OPERATOR = "++, --, .., <>"
    // https://github.com/elixir-lang/elixir/commit/3487d00ddb5e90c7cf0e65d03717903b9b27eafd
    THREE_OPERATOR = "^^^"
    TYPE_OPERATOR = "::"
    UNARY_OPERATOR = "~~~, !, ^"
    UNICODE_ESCAPE_CHARACTER = "u"
    UNKNOWN_WHOLE_NUMBER_BASE = "A-Z, a, c-n, p-w, z"
    VALID_BINARY_DIGITS = "0-1"
    VALID_DECIMAL_DIGITS = "0-9"
    VALID_HEXADECIMAL_DIGITS = "A-F, a-f, 0-9"
    VALID_OCTAL_DIGITS = "0-7"
    WHEN_OPERATOR = "when"
    WORDS_FRAGMENT = "Words Fragment"
    WORDS_HEREDOC_PROMOTER = "Words Heredoc Promoter (\"\"\", ''')"
    WORDS_HEREDOC_TERMINATOR = "Words Heredoc Terminator (\"\"\", ''')"
    WORDS_PROMOTER = "Words Promoter ({, [, <, \", /, (, |, ')"
    WORDS_TERMINATOR = "Words Terminator ({, [, <, \", /, (, |, ')"
  ]
}

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
private elixirFile ::= endOfExpression? (expressionList endOfExpression?)?

/*
 *
 *
 * Expression List
 *
 *
 */

private infixSemicolon ::= EOL* SEMICOLON EOL*
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= infixSemicolon | EOL+ { implements = "org.elixir_lang.psi.Unquoted" }

/*
 *
 * Expression
 *
 */

private expression ::= emptyParentheses |
                       unmatchedExpression |
                       unqualifiedNoParenthesesManyArgumentsCall
                       { recoverWhile = expressionRecoverWhile }
// EOL and SEMICOLON for endOfExpression
/* INTERPOLATION_END because interpolation(elixirFile(expression)) needs expression to stop of on INTERPOLATION_END for
   interpolation */
// END for stabBody's usage of expression
// CLOSING_* because they are endings to subexpressions
// STAB_OPERATOR because it ends when clause for no parentheses stab guard clauses
// blockIdentifier for one-liner blockItems where there isn't a newline between block expressions and following blockIdentifier.
private expressionRecoverWhile ::= !(EOL | CLOSING_BIT | CLOSING_BRACKET | CLOSING_CURLY | CLOSING_PARENTHESIS | INTERPOLATION_END | SEMICOLON | STAB_OPERATOR | END | blockIdentifier)

private expressionList ::= expression (endOfExpression expression)*

/*
 *
 *
 * Function Calls
 *
 *
 */

/*
 *
 * No Parentheses
 *
 */

/*
 * Many Arguments
 */

/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
private noParenthesesExpression ::= emptyParentheses |
                                    /* Must be before matchedExpression because noParenthesesExpression is
                                       `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict` which is
                                       longer than `matchedExpressionDotIdentifier` in matchedExpression. */
                                    /* This will be marked as an error by
                                       {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                                    noParenthesesManyStrictNoParenthesesExpression |
                                    matchedExpression
/* Special class for wrapping noParenthesesCall so that
   {@link: org.elixir_lang.inspection.NoParenthesesManyStrict} can just search for
   ElixirNoParenthesesManyStrictNoParenthesesExpression isn't of having to differentiate between valid and invalid
   ElixirNoParenthesesCall. */
noParenthesesManyStrictNoParenthesesExpression ::= unqualifiedNoParenthesesManyArgumentsCall
                                                   { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS
                        {
                          implements = [
                            "org.elixir_lang.psi.Arguments"
                            "org.elixir_lang.psi.QuotableArguments"
                          ]
                          methods = [
                            arguments
                            quoteArguments
                          ]
                        }

/* 1. (positional, keywords)
   2. (positional, positional)
   3. (positional, positional, keywords) */
private noParenthesesManyArguments ::= matchedExpression infixComma noParenthesesKeywords |
                                       !additionTail matchedExpression (infixComma noParenthesesExpression)+ (infixComma noParenthesesKeywords)?
private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict

// A rule instead of a token so that there is a PsiElement to return from getNameIdentifier
identifier ::= IDENTIFIER_TOKEN
               {
                 implements = "org.elixir_lang.psi.Quotable"
                 methods = [
                   getPresentation
                   quote
                 ]
               }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
unqualifiedNoParenthesesManyArgumentsCall ::= identifier !KEYWORD_PAIR_COLON
                                              noParenthesesManyArgumentsStrict
                                              {
                                                implements = [
                                                  // MUST be first so visitElement is used in ElixirVisitor
                                                  "com.intellij.psi.PsiElement"
                                                  "org.elixir_lang.psi.call.StubBased<org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall>"
                                                  "org.elixir_lang.psi.call.arguments.star.NoParentheses"
                                                  "org.elixir_lang.psi.qualification.Unqualified"
                                                  "org.elixir_lang.psi.Quotable"
                                                ]
                                                mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall>"
                                                stubClass = "org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall"
                                              }

/*
 * 1+ Arguments
 */

noParenthesesKeywords ::= noParenthesesKeywordPair (infixComma noParenthesesKeywordPair)*
                          {
                            implements = "org.elixir_lang.psi.QuotableKeywordList"
                            methods = [
                              quotableKeywordPairList
                              quote
                            ]
                          }
noParenthesesKeywordPair ::= keywordKeyColonEOL noParenthesesExpression
                             {
                               implements = "org.elixir_lang.psi.QuotableKeywordPair"
                               methods = [
                                 getKeywordKey
                                 getKeywordValue
                                 quote
                               ]
                             }

/*
 * 0 Arguments
 */

variable ::= IDENTIFIER_TOKEN !KEYWORD_PAIR_COLON
             {
               implements = [
                 "org.elixir_lang.psi.NamedElement"
                 "org.elixir_lang.psi.Quotable"
               ]
               methods = [
                 getName
                 getNameIdentifier
                 quote
                 setName
               ]
             }

/*
 *
 *
 * Heredoc
 *
 *
 */

heredocLinePrefix ::= HEREDOC_LINE_WHITE_SPACE_TOKEN? { methods = [excessWhitespace] }
heredocPrefix ::= HEREDOC_PREFIX_WHITE_SPACE?

/*
 *
 * Quote Heredocs
 *
 */

/*
 * CharList Heredoc
 */

charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    charListHeredocLine*
                    heredocPrefix CHAR_LIST_HEREDOC_TERMINATOR
                    {
                      implements = [
                        "org.elixir_lang.psi.Heredoc"
                        "org.elixir_lang.psi.InterpolatedCharList"
                        "org.elixir_lang.psi.Quote"
                      ]
                      pin = 1
                    }
charListHeredocLine ::= heredocLinePrefix quoteCharListBody EOL
                        {
                          implements = [
                            "org.elixir_lang.psi.HeredocLine"
                          ]
                          methods = [
                            getBody
                            quote
                          ]
                        }

/*
 * String Heredoc
 */

stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  stringHeredocLine*
                  heredocPrefix STRING_HEREDOC_TERMINATOR
                  {
                    implements = [
                      "org.elixir_lang.psi.Heredoc"
                      "org.elixir_lang.psi.InterpolatedString"
                    ]
                    pin = 1
                  }
stringHeredocLine ::= heredocLinePrefix quoteStringBody EOL
                      {
                        implements = [
                          "org.elixir_lang.psi.HeredocLine"
                        ]
                        methods = [
                          getBody
                          quote
                        ]
                      }

/*
 *
 * Interpolated Sigil Heredocs
 *
 */

sigilModifiers ::= SIGIL_MODIFIER* { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

interpolatedCharListSigilHeredoc ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedCharListHeredocLine*
                                     heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.CharListFragmented"
                                         "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                                         "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                       ]
                                       pin = 3
                                     }
interpolatedCharListHeredocLine ::= heredocLinePrefix interpolatedCharListBody EOL
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.HeredocLine"
                                      ]
                                      methods = [
                                        getBody
                                        quote
                                      ]
                                    }
interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | sigilEscapeSequence)*
                             { implements = "org.elixir_lang.psi.Body" }

interpolatedRegexHeredoc ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                             interpolatedRegexHeredocLine*
                             heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.RegexFragmented"
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                               ]
                               pin = 3
                             }
interpolatedRegexHeredocLine ::= heredocLinePrefix interpolatedRegexBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | sigilEscapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedSigilHeredoc ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                             interpolatedSigilHeredocLine*
                             heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                 "org.elixir_lang.psi.SigilFragmented"
                               ]
                               pin = 3
                             }
interpolatedSigilHeredocLine ::= heredocLinePrefix interpolatedSigilBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | sigilEscapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedStringSigilHeredoc ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                   interpolatedStringHeredocLine*
                                   heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                   {
                                     implements = [
                                       "org.elixir_lang.psi.StringFragmented"
                                       "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                       "org.elixir_lang.psi.InterpolatedStringHeredocLined"
                                     ]
                                     pin = 3
                                   }
interpolatedStringHeredocLine ::= heredocLinePrefix interpolatedStringBody EOL
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.HeredocLine"
                                    ]
                                    methods = [
                                      getBody
                                      quote
                                    ]
                                  }
interpolatedStringBody ::= (interpolation | STRING_FRAGMENT | sigilEscapeSequence)*
                           { implements = "org.elixir_lang.psi.Body" }

interpolatedWordsHeredoc ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                             interpolatedWordsHeredocLine*
                             heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.WordsFragmented"
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                               ]
                               pin = 3
                             }
interpolatedWordsHeredocLine ::= heredocLinePrefix interpolatedWordsBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | sigilEscapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

/*
 * Literal Sigil Heredocs
 */

literalCharListSigilHeredoc ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                literalCharListHeredocLine*
                                heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.CharListFragmented"
                                    "org.elixir_lang.psi.LiteralSigilHeredoc"
                                  ]
                                  pin = 3
                                }
literalCharListHeredocLine ::= heredocLinePrefix literalCharListBody EOL
                               {
                                 implements = [
                                   "org.elixir_lang.psi.HeredocLine"
                                 ]
                                 methods = [
                                   getBody
                                   quote
                                 ]
                               }
// literals can have escape sequences for escaped terminator
literalCharListBody ::= (CHAR_LIST_FRAGMENT | sigilEscapeSequence)*
                        { implements = "org.elixir_lang.psi.Body" }

literalRegexHeredoc ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                        literalRegexHeredocLine*
                        heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.RegexFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = 3
                        }
literalRegexHeredocLine ::= heredocLinePrefix literalRegexBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalRegexBody ::= (REGEX_FRAGMENT | sigilEscapeSequence)*
                     { implements = "org.elixir_lang.psi.Body" }

literalSigilHeredoc ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                        literalSigilHeredocLine*
                        heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.SigilFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = 3
                        }
literalSigilHeredocLine ::= heredocLinePrefix literalSigilBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalSigilBody ::= (SIGIL_FRAGMENT | sigilEscapeSequence)*
                     { implements = "org.elixir_lang.psi.Body" }

literalStringSigilHeredoc ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                              literalStringHeredocLine*
                              heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                              {
                                implements = [
                                  "org.elixir_lang.psi.StringFragmented"
                                  "org.elixir_lang.psi.LiteralSigilHeredoc"
                                ]
                                pin = 3
                              }
literalStringHeredocLine ::= heredocLinePrefix literalStringBody EOL
                             {
                               implements = [
                                 "org.elixir_lang.psi.HeredocLine"
                               ]
                               methods = [
                                 getBody
                                 quote
                               ]
                             }
// literals can have escape sequences for escaped terminator
literalStringBody ::= (STRING_FRAGMENT | sigilEscapeSequence)*
                      { implements = "org.elixir_lang.psi.Body" }

literalWordsHeredoc ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                        literalWordsHeredocLine*
                        heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.WordsFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = 3
                        }
literalWordsHeredocLine ::= heredocLinePrefix literalWordsBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalWordsBody ::= (WORDS_FRAGMENT | sigilEscapeSequence)*
                     { implements = "org.elixir_lang.psi.Body" }

/*
 *
 *
 * Lines (as opposed to Heredocs)
 *
 *
 */

/*
 *
 * Quote Lines
 *
 */


quoteCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | quoteEscapeSequence)*
                      { implements =  "org.elixir_lang.psi.Body" }
charListLine ::= CHAR_LIST_PROMOTER quoteCharListBody CHAR_LIST_TERMINATOR
                 {
                   implements = [
                     "org.elixir_lang.psi.Atomable"
                     "org.elixir_lang.psi.InterpolatedCharList"
                     "org.elixir_lang.psi.Line"
                     "org.elixir_lang.psi.Quotable"
                   ]
                 }

quoteStringBody ::=  (interpolation | STRING_FRAGMENT | quoteEscapeSequence)*
                     { implements = "org.elixir_lang.psi.Body" }
stringLine ::= STRING_PROMOTER quoteStringBody STRING_TERMINATOR
               {
                 implements = [
                   "org.elixir_lang.psi.Atomable"
                   "org.elixir_lang.psi.InterpolatedString"
                   "org.elixir_lang.psi.Line"
                   "org.elixir_lang.psi.Quotable"
                 ]
               }

/*
 *
 * Sigil Lines
 *
 */

/*
 * Interpolated Sigil Lines
 */

interpolatedCharListSigilLine ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.CharListFragmented"
                                      "org.elixir_lang.psi.InterpolatedSigilLine"
                                    ]
                                  }

interpolatedRegexLine ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.RegexFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                          }

interpolatedSigilLine ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.SigilFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                          }

interpolatedStringSigilLine ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.StringFragmented"
                                    "org.elixir_lang.psi.InterpolatedSigilLine"
                                  ]
                                }

interpolatedWordsLine ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_PROMOTER interpolatedWordsBody WORDS_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.WordsFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                          }
/*
 * Literal Sigils
 */

literalCharListSigilLine ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.CharListFragmented"
                                 "org.elixir_lang.psi.LiteralSigilLine"
                               ]
                             }

literalRegexLine ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.RegexFragmented"
                         "org.elixir_lang.psi.LiteralSigilLine"
                       ]
                     }

literalSigilLine ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.LiteralSigilLine"
                         "org.elixir_lang.psi.SigilFragmented"
                       ]
                     }

literalStringSigilLine ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR sigilModifiers
                           {
                             implements = [
                               "org.elixir_lang.psi.StringFragmented"
                               "org.elixir_lang.psi.LiteralSigilLine"
                             ]
                           }

literalWordsLine ::=  TILDE LITERAL_WORDS_SIGIL_NAME WORDS_PROMOTER literalWordsBody WORDS_TERMINATOR sigilModifiers
                      {
                        implements = [
                          "org.elixir_lang.psi.WordsFragmented"
                          "org.elixir_lang.psi.LiteralSigilLine"
                        ]
                      }

/*
 *
 *
 * Matched Expressions - ordered by outer-most (lowest precedence) to inner-most (highest precedence)
 *
 * See ELIXIR_BNF_DESIGN.md for exanplanation of the naming and nesting pattern used in the matchedExpression rules.
 *
 *
 */

matchedExpression ::= matchedCaptureNonNumericOperation |
                      matchedInMatchOperation |
                      /* noParenthesesKeywords needs to be first as matchedExpression will match due to the error
                         handling built into the Pratt parser. */
                      matchedWhenNoParenthesesKeywordsOperation |
                      matchedWhenOperation |
                      matchedTypeOperation |
                      matchedPipeOperation |
                      matchedMatchOperation |
                      matchedOrOperation |
                      matchedAndOperation |
                      matchedComparisonOperation |
                      matchedRelationalOperation |
                      matchedArrowOperation |
                      matchedInOperation |
                      matchedThreeOperation |
                      matchedTwoOperation |
                      matchedAdditionOperation |
                      matchedMultiplicationOperation |
                      matchedUnaryNonNumericOperation |
                      matchedDotCall |
                      // NoParentheses before matchedBracketOperation because brackets only make sense after parentheses.
                      matchedQualifiedNoParenthesesCall |
                      matchedAtUnqualifiedNoParenthesesCall |
                      matchedUnqualifiedNoParenthesesCall |
                      matchedBracketOperation |
                      matchedQualifiedAlias |
                      matchedQualifiedMultipleAliases |
                      matchedQualifiedBracketOperation |
                      matchedQualifiedParenthesesCall |
                      matchedQualifiedNoArgumentsCall |
                      matchedAtUnqualifiedBracketOperation |
                      matchedAtNonNumericOperation | // after matchedQualified because @ binds only before `.`
                      matchedUnqualifiedParenthesesCall |
                      matchedUnqualifiedBracketOperation |
                      matchedUnqualifiedNoArgumentsCall |
                      matchedAccessExpression

/*
 * Capture Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50
 */

capturePrefixOperator ::= CAPTURE_OPERATOR EOL*
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "&"
                          }
matchedCaptureNonNumericOperation ::= capturePrefixOperator !numeric matchedExpression

/*
 * In Match Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L51
 */

inMatchInfixOperator ::= EOL* IN_MATCH_OPERATOR EOL*
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "<-, \\\\"
                    }
// implements and methods defined by "infix operations" section above
matchedInMatchOperation ::= matchedExpression inMatchInfixOperator matchedExpression

/*
 * When Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L52
 */

whenInfixOperator ::= EOL* WHEN_OPERATOR EOL*
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "when"
                      }
/* noParenthesesKeywords needs to be in a separate operation so that only matchedWhenNoParenthesesKeywordsOperation is a
   POSTFIX operation and matchedWhenOperation can remain a BINARY operation.  With
   `(noParenthesesKeywords | matchedExpression)` as the right operand, matchdWhenExpression was a POSTFIX operator,
   which caused the precedence for matchedInMatchOperand and matchedWhenOperation to be wrong as demonstrated in
   49ffef5a33ca1102213821efb4e2140f97622ca1 by
   org.elixir_lang.parser_definition.MatchedINMatchOperationParsingTestCase.testMatchedWhenOperation. */
matchedWhenNoParenthesesKeywordsOperation ::= matchedExpression whenInfixOperator noParenthesesKeywords
                                              { elementType = matchedWhenOperation rightAssociative = true }
// implements and methods defined by "infix operations" section above
matchedWhenOperation ::= matchedExpression whenInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Type Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L53
 */

typeInfixOperator ::= EOL* TYPE_OPERATOR EOL*
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "::"
                      }
// implements and methods defined by "infix operations" section above
matchedTypeOperation ::= matchedExpression typeInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Pipe Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L54
 */

pipeInfixOperator ::= EOL* PIPE_OPERATOR EOL*
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "|"
                      }
// implements and methods defined by "infix operations" section above
matchedPipeOperation ::= matchedExpression pipeInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Match Operation - right-associative
 *
 * @see see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L56
 */

matchInfixOperator ::= EOL* MATCH_OPERATOR EOL*
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "="
                       }
// implements and methods defined by "infix operations" section above
matchedMatchOperation ::= matchedExpression matchInfixOperator matchedExpression
                          { rightAssociative = true }

/*
 * Or Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L57
 */

orInfixOperator ::= EOL* OR_OPERATOR EOL*
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "||, |||, or"
                    }
// implements and methods defined by "infix operations" section above
matchedOrOperation ::= matchedExpression orInfixOperator matchedExpression

/*
 * And Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L58
 */
andInfixOperator ::= EOL* AND_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "&&, &&&, and"
                     }
// implements and methods defined by "infix operations" section above
matchedAndOperation ::= matchedExpression andInfixOperator matchedExpression

/*
 * Comparison Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L59
 */

comparisonInfixOperator ::= EOL* COMPARISON_OPERATOR EOL*
                            {
                              implements = "org.elixir_lang.psi.Operator"
                              methods = [
                                operatorTokenSet
                                quote
                              ]
                              name = "!=, ==, =~, !==, ==="
                            }
// implements and methods defined by "infix operations" section above
matchedComparisonOperation ::= matchedExpression comparisonInfixOperator matchedExpression

/*
 * Relational Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L60
 */

relationalInfixOperator ::= EOL* RELATIONAL_OPERATOR EOL*
                            {
                              implements = "org.elixir_lang.psi.Operator"
                              methods = [
                                operatorTokenSet
                                quote
                              ]
                              name = "<, >, <=, >="
                            }
// implements and methods defined by "infix operations" section above
matchedRelationalOperation ::= matchedExpression relationalInfixOperator matchedExpression

/*
 * Arrow Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L61
 */

arrowInfixOperator ::= EOL* ARROW_OPERATOR EOL*
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "<~, |>, ~>, <<<, <<~, <|>, <~>, >>>, ~>>"
                       }
// implements and methods defined by "infix operations" section above
matchedArrowOperation ::= matchedExpression arrowInfixOperator matchedExpression

/*
 * In Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L62
 */

inInfixOperator ::= EOL* IN_OPERATOR EOL*
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "in"
                    }
// implements defined by "in operations" section above
// methods defined by "infix operations" section above
matchedInOperation ::= matchedExpression inInfixOperator matchedExpression

/*
 * Three Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/3487d00ddb5e90c7cf0e65d03717903b9b27eafd/lib/elixir/src/elixir_parser.yrl#L67
 */
threeInfixOperator ::= EOL* THREE_OPERATOR EOL*
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "^^^"
                       }
// implements and methods defined by "infix operations" section above
matchedThreeOperation ::= matchedExpression threeInfixOperator matchedExpression

/*
 * Two Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L63
 */

twoInfixOperator ::= EOL* TWO_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "++, --, .., <>"
                     }
// implements and methods defined by "infix operations" section above
matchedTwoOperation ::= matchedExpression twoInfixOperator matchedExpression
                        { rightAssociative = true }

/*
 * Addition Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L64
 *
 */

/* Unlike other binary operation, additionOperations cannot begin with EOLs: if there are EOLs, then the +/- is
   interpreted as unaryOperation.

   See https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L605-L613
   for rules for SIGNIFICANT_WHITE_SPACE */
additionInfixOperator ::= (SIGNIFICANT_WHITE_SPACE DUAL_OPERATOR (SIGNIFICANT_WHITE_SPACE | &EOL) |
                           DUAL_OPERATOR) EOL*
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "+, -"
                          }
// implements and methods defined by "infix operations" section above
matchedAdditionOperation ::= matchedExpression additionInfixOperator matchedExpression

/*
 * Multiplication Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65
 *
 */

multiplicationInfixOperator ::= EOL* MULTIPLICATION_OPERATOR EOL*
                                {
                                  implements = "org.elixir_lang.psi.Operator"
                                  methods = [
                                    operatorTokenSet
                                    quote
                                  ]
                                  name = "*, /"
                                }
// implements and methods defined by "infix operations" section above
matchedMultiplicationOperation ::= matchedExpression multiplicationInfixOperator matchedExpression

/*
 * Unary Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67
 *
 */

unaryPrefixOperator ::= (SIGNIFICANT_WHITE_SPACE? DUAL_OPERATOR | NOT_OPERATOR | UNARY_OPERATOR) EOL*
                        {
                          implements = "org.elixir_lang.psi.Operator"
                          methods = [
                            operatorTokenSet
                            quote
                          ]
                          name = "+, -, !, ^, not, ~~~"
                        }
matchedUnaryNonNumericOperation ::= unaryPrefixOperator !numeric matchedExpression

/*
 * Dot Operations
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L561-L565
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69)
dotInfixOperator ::= EOL* DOT_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       name = "."
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                     }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L71
// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L121
relativeIdentifier ::= IDENTIFIER_TOKEN |
                       AFTER |
                       AND_OPERATOR |
                       ARROW_OPERATOR |
                       // NOT ASSOCIATION_OPERATOR
                       AT_OPERATOR |
                       // NOT BIT_STRING_OPERATOR because it is a special form
                       CAPTURE_OPERATOR |
                       CATCH |
                       COMPARISON_OPERATOR |
                       DO |
                       DUAL_OPERATOR SIGNIFICANT_WHITE_SPACE? |
                       ELSE |
                       END |
                       IN_MATCH_OPERATOR |
                       IN_OPERATOR |
                       // NOT MAP_OPERATOR because it is a special form
                       MATCH_OPERATOR |
                       MULTIPLICATION_OPERATOR |
                       OR_OPERATOR |
                       PIPE_OPERATOR |
                       RELATIONAL_OPERATOR |
                       RESCUE |
                       STAB_OPERATOR |
                       STRUCT_OPERATOR |
                       THREE_OPERATOR |
                       // NOT TUPLE_OPERATOR because it is a special form
                       TWO_OPERATOR |
                       UNARY_OPERATOR |
                       WHEN_OPERATOR |
                       atomKeyword |
                       charListLine |
                       stringLine
                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/master/lib/elixir/src/elixir_parser.yrl#L481-L482
private parenthesesPositionalArguments ::= containerArgumentsBase

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L484-L488
parenthesesArguments ::= OPENING_PARENTHESIS EOL*
                         (
                          unqualifiedNoParenthesesManyArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L485
                          keywords | // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L486
                          parenthesesPositionalArguments (infixComma keywords)?)? EOL* // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L487-L488
                         CLOSING_PARENTHESIS
                         {
                           implements = [
                             "org.elixir_lang.psi.Arguments"
                             "org.elixir_lang.psi.QuotableArguments"
                           ]
                           methods = [
                             arguments
                             quoteArguments
                           ]
                         }

// call_args_no_parens_one
noParenthesesOneArgument ::= noParenthesesKeywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L417
                             unqualifiedNoParenthesesManyArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L419
                             /* This should NOT be in matchedExpression as it's not in matched_expr, but in no_parens_expr,
                                but having a rule that starts with matchedExpression is only legal in a rule that extends
                                matchedExpression.

                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125 */
                             noParenthesesManyArgumentsStrict |
                             /* MUST be after noParenthesesManyArgumentsStrict so that matchedExpression's inbuilt error handling doesn't match with error.

                                NOTE this is used in both unmatchedExpression and matchedExpression.  Using
                                matchedExpression here ensures the `do` block is only consumed by the left-most
                                unmatchedExpression call and not any of the middle matchedExpression calls.

                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L418
                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L609-L610 */
                             !additionTail matchedExpression
                             {
                               implements = [
                                 "org.elixir_lang.psi.Arguments"
                                 "org.elixir_lang.psi.MaybeModuleName"
                                 "org.elixir_lang.psi.QuotableArguments"
                               ]
                               methods = [
                                 arguments
                                 isModuleName
                                 processDeclarations
                                 quoteArguments
                               ]
                             }

/* @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L418
  @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L609-L610 */
private additionTail ::= SIGNIFICANT_WHITE_SPACE? DUAL_OPERATOR (
                           // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L610
                           "/" | ">" | DUAL_OPERATOR | STRUCT_OPERATOR |
                           // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L609
                           OPENING_BIT | OPENING_BRACKET | OPENING_CURLY | OPENING_PARENTHESIS |
                           // white spaces
                           EOL | SIGNIFICANT_WHITE_SPACE
                         )
                         |
                         DUAL_OPERATOR

matchedParenthesesArguments ::= CALL parenthesesArguments parenthesesArguments? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L254-255

/*
 * Dot (Anonymous function) Call Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L403
 */

matchedDotCall ::= matchedExpression dotInfixOperator parenthesesArguments parenthesesArguments?
                   {
                     implements = [
                       "org.elixir_lang.psi.DotCall<org.elixir_lang.psi.stub.MatchedDotCall>"
                       "org.elixir_lang.psi.MatchedCall"
                     ]
                     mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedDotCall>"
                     stubClass = "org.elixir_lang.psi.stub.MatchedDotCall"
                   }

/*
 * Qualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

matchedQualifiedNoParenthesesCall ::= matchedExpression dotInfixOperator relativeIdentifier noParenthesesOneArgument
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.QualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall"
                                      }

/*
 * At Operation on Unqualified No Parentheses CALL
 *
 * Needed because matchedAtNonNumericOperation must be after * matchedQualified* and matchedBracketOperation, but
 * matchedUnqualifiedNoParenthesesCall needs to be an operand of At so that the entire call is an operand instead of
 * just the variable.
 */

matchedAtUnqualifiedNoParenthesesCall ::= atIdentifier noParenthesesOneArgument
                                          {
                                            implements = [
                                              "org.elixir_lang.psi.AtUnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall>"
                                              "org.elixir_lang.psi.MatchedCall"
                                            ]
                                            mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall>"
                                            stubClass = "org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall"
                                          }

/*
 * Unqualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

matchedUnqualifiedNoParenthesesCall ::= identifier noParenthesesOneArgument
                                        {
                                          implements = [
                                            "org.elixir_lang.psi.MatchedCall"
                                            "org.elixir_lang.psi.UnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall>"
                                          ]
                                          methods = [
                                            canonicalName
                                            canonicalNameSet
                                            exportedArity
                                            exportedName
                                            functionName
                                            functionNameElement
                                            getDoBlock
                                            hasDoBlockOrKeyword
                                            isExported
                                            getName
                                            getNameIdentifier
                                            getPresentation
                                            getReference
                                            getStub
                                            getUseScope
                                            isCalling
                                            isCallingMacro
                                            moduleName
                                            primaryArguments
                                            primaryArity
                                            processDeclarations
                                            quote
                                            resolvedFinalArity
                                            resolvedFinalArityRange
                                            resolvedModuleName
                                            resolvedPrimaryArity
                                            resolvedSecondaryArity
                                            secondaryArguments
                                            secondaryArity
                                            setName
                                          ]
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall"
                                        }

/*
 * Bracket Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L238
 */

bracketArguments ::= OPENING_BRACKET EOL*
                     (
                      keywords |
                      containerExpression infixComma?
                     )
                     CLOSING_BRACKET
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

matchedBracketOperation ::= matchedExpression bracketArguments
                            { implements = "org.elixir_lang.psi.BracketOperation" methods = [quote] }

/*
 * Qualified Alias
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L388
 */

matchedQualifiedAlias ::= matchedExpression dotInfixOperator alias
                          {
                            implements = [
                              "org.elixir_lang.psi.NamedElement"
                              "org.elixir_lang.psi.QualifiedAlias"
                            ]
                            methods = [
                              fullyQualifiedName
                              getName
                              getNameIdentifier
                              getReference
                              isModuleName
                              processDeclarations
                              quote
                              setName
                            ]
                          }

/*
 * Qualified Multiple Alias
 *
 * See https://github.com/elixir-lang/elixir/pull/3666
 */
matchedQualifiedMultipleAliases ::= matchedExpression dotInfixOperator multipleAliases

// same rules as tuple, but quoting is different, so separate rule.
multipleAliases ::= OPENING_CURLY EOL*
                    containerArguments? EOL*
                    CLOSING_CURLY
                    {
                      implements = "org.elixir_lang.psi.Quotable"
                      methods = [
                        processDeclarations
                        quote
                      ]
                    }


/*
 * Qualified Identifier Bracket Operation
 */

matchedQualifiedBracketOperation ::= matchedExpression dotInfixOperator relativeIdentifier CALL bracketArguments

/*
 * Qualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

matchedQualifiedParenthesesCall ::= matchedExpression dotInfixOperator relativeIdentifier matchedParenthesesArguments
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.MatchedCall"
                                        "org.elixir_lang.psi.QualifiedParenthesesCall<org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall>"
                                      ]
                                      mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall>"
                                      stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall"
                                    }

/*
 * Qualified Call with No Arguments - neither parenthes nor no parentheses
 */

matchedQualifiedNoArgumentsCall ::= matchedExpression dotInfixOperator relativeIdentifier !CALL
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.MatchedCall"
                                        "org.elixir_lang.psi.QualifiedNoArgumentsCall<org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall>"
                                      ]
                                      mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall>"
                                      stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall"
                                    }

/*
 * At Unqualified Bracket Operation
 *
 * Needed so that At consumes Unqualified identifier, but brackets consume both of them.
 */

matchedAtUnqualifiedBracketOperation ::= atPrefixOperator IDENTIFIER_TOKEN CALL bracketArguments
                                         { implements = "org.elixir_lang.psi.AtUnqualifiedBracketOperation" methods = [quote] }

/*
 * Unqualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

matchedUnqualifiedParenthesesCall ::= identifier matchedParenthesesArguments
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.UnqualifiedParenthesesCall<org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall"
                                      }

/*
 * At Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

atPrefixOperator ::= AT_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "@"
                     }
matchedAtNonNumericOperation ::= atPrefixOperator !numeric matchedExpression

/*
 * Unqualified Bracket Operation
 */

matchedUnqualifiedBracketOperation ::= identifier CALL bracketArguments
                                       {
                                         implements = "org.elixir_lang.psi.UnqualifiedBracketOperation"
                                         methods = [quote]
                                       }


/*
 * Unqualified No Arguments Call
 */

matchedUnqualifiedNoArgumentsCall ::= identifier !KEYWORD_PAIR_COLON
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.UnqualifiedNoArgumentsCall<org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall"
                                      }


matchedAccessExpression ::= accessExpression
                            { elementType = accessExpression }

/*
 * Access expression
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L200-L223
 *
 */

atNumericOperation ::= atPrefixOperator numeric
captureNumericOperation ::= capturePrefixOperator numeric
unaryNumericOperation ::= unaryPrefixOperator numeric

/*
 *
 * Map
 *
 */

/*
 * https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L430-L430
 * shows that '%{}' is injected by the Elixir native tokenizer when '%{' is encountered.  Since Elixir.flex can't inject
 * text, this parser is matching MAP_OPERATOR as just '%' as mapArguments contains the '{'.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L521-L522
 */
mapPrefixOperator ::= STRUCT_OPERATOR EOL*
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "%"
                      }

private associationInfixOperator ::= EOL* ASSOCIATION_OPERATOR EOL*

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L505
containerAssociationOperation ::= containerExpression associationInfixOperator containerExpression
                                  { implements = "org.elixir_lang.psi.AssociationOperation" methods = [quote] }

left maxDotCall ::= dotInfixOperator parenthesesArguments parenthesesArguments?
                    { elementType = matchedDotCall }

left maxQualifiedAlias ::= dotInfixOperator alias
                           { elementType = matchedQualifiedAlias }

left maxQualifiedParenthesesCall ::= dotInfixOperator relativeIdentifier matchedParenthesesArguments
                                     { elementType = matchedQualifiedParenthesesCall }

left maxQualifiedNoArgumentsCall ::= dotInfixOperator relativeIdentifier !CALL
                                     { elementType = matchedQualifiedNoArgumentsCall }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L226-L231
private maxExpression ::= /* matchedBracketOperation because it is first rule after matchedDotCallOperation that will
                             take a `.`. */
                          matchedBracketOperation maxDotCall |
                          /* matchedQualifiedBracketOperation because it is in the Pratt-parsing table for
                             matchedExpression will match matchedQualifiedBracketOperation or anything after it in
                             matchedExpression.  matchedQualifiedBracketOperation is used because it is the next rule
                             after matchedQualifiedAliasOperation. maxQualifiedAlias needs to be `left` and `+` to
                             emulate the POSTFIX behavior for matchedQualifiedAliasOperation.

                             matchedQualifiedAliasOperation cannot be used because the Pratt-parsing table will allow
                             matchedQualifiedAliasOperation to match it or any lower rule. */
                          matchedQualifiedBracketOperation maxQualifiedAlias+ | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          /* matchedQualifiedNoArgumentsCall because it is first rule after
                            matchedQualifiedParenthesesCall */
                          matchedQualifiedNoArgumentsCall maxQualifiedParenthesesCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          /* matchedAtUnqualifiedBracketOperation and all rules thrugh accessExpression are necessary
                             because all those rules are ATOM or PREFIX so they won't also match lower rules */
                          (
                           matchedAtUnqualifiedBracketOperation |
                           matchedAtNonNumericOperation |
                           matchedUnqualifiedParenthesesCall |
                           matchedUnqualifiedBracketOperation |
                           variable |
                           accessExpression
                          ) maxQualifiedNoArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L499
                          matchedUnqualifiedParenthesesCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          variable | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L499
                          atom | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L226-L228
                          alias // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231

/*
 * Map Expression
 */

atMaxExpression ::= atPrefixOperator maxExpression
                    { elementType = matchedAtNonNumericOperation }

/* Anything that can hold a map.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L498-L500
 */
private mapExpression ::= maxExpression | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L498-L499
                          atMaxExpression // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L500

private associationsExpression ::= containerAssociationOperation | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L505
                                   mapExpression // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L506
associationsBase ::= associationsExpression (infixComma associationsExpression)*
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
associations ::= associationsBase infixComma?
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Arguments at tail of mapUpdateArguments and mapConstructionArguments
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L524-L526
 */
private mapTailArguments ::= // Must be before associations so identifiers as keyword keys match before maxExpression in associations
                             keywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L524
                             associationsBase infixComma keywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L526
                             associations // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L525

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L530-L533
mapUpdateArguments ::= matchedMatchOperation pipeInfixOperator mapTailArguments
                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

mapConstructionArguments ::= mapTailArguments
                             {
                               implements = "org.elixir_lang.psi.QuotableArguments"
                               methods = [
                                 arguments
                                 quoteArguments
                               ]
                             }

mapArguments ::= OPENING_CURLY EOL*
                 (
                  // Must be before mapConstructionArguments, so that PIPE_OPERATOR is used for updates and not matchedExpression.
                  mapUpdateArguments |
                  mapConstructionArguments
                 )? EOL*
                 CLOSING_CURLY
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }


mapOperation ::= mapPrefixOperator mapArguments
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

structOperation ::= mapPrefixOperator mapExpression EOL* mapArguments
                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private map ::= mapOperation |
                structOperation

/*
 * Stab Operation
 */

noParenthesesArguments ::= noParenthesesOneArgument |
                           noParenthesesManyArguments
                           { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L276-L277
stabNoParenthesesSignature ::= noParenthesesArguments
                               { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * `fn (unquote_splicing([1,2,3])) -> end` is valid, but not obvious from elixir_parser.yrl that appears to only allow
 * keywords or many arguments.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L278-L281
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L430-L432
 */
stabParenthesesSignature ::= parenthesesArguments (whenInfixOperator expression)?
                             {
                               implements = [
                                 "org.elixir_lang.psi.Quotable"
                                 "org.elixir_lang.psi.operation.When"
                               ]
                               methods = [
                                 getNameIdentifier
                                 leftOperand
                                 operator
                                 quote
                                 rightOperand
                               ]
                             }

stabInfixOperator ::= EOL* STAB_OPERATOR EOL*
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "->"
                      }

/*
 * stabParenthesesSignature must be at same level as stabInfixOperator so that stabParenthesesSignature does not match
 * beginning of stabNoParenthesesSignature that begins with a parentheticalStab, `(one) <op> two ->`.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L283-L284
 *    for optionalness
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L687-L702
 *    for grouping stab followed by expression into stab, so it is equivalent to expr_list (expressionList)
 */
private stabOperationPrefix ::= stabParenthesesSignature stabInfixOperator |
                                stabNoParenthesesSignature stabInfixOperator |
                                stabInfixOperator
private stabBodyExpression ::= !stabOperationPrefix expression
stabBody ::= stabBodyExpression (endOfExpression stabBodyExpression)*
             {
               implements = "org.elixir_lang.psi.Quotable"
               methods = [
                 processDeclarations
                 quote
               ]
             }

stabOperation ::= stabOperationPrefix stabBody?
                  {
                    implements = "org.elixir_lang.psi.Quotable"
                    methods = [
                      leftOperand
                      operator
                      processDeclarations
                      quote
                      rightOperand
                    ]
                  }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L268-L269
stab ::= stabOperation (endOfExpression stabOperation)* |
         stabBody
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L205
anonymousFunction ::= FN endOfExpression?
                      stab endOfExpression?
                      END
                      {
                        implements = [
                          "com.intellij.psi.NavigatablePsiElement"
                          "org.elixir_lang.psi.Quotable"
                        ]
                        methods = [
                          quote
                        ]
                      }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L206-L210
parentheticalStab ::= OPENING_PARENTHESIS EOL*
                      (infixSemicolon? stab infixSemicolon? | infixSemicolon)
                      EOL* CLOSING_PARENTHESIS
                      { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Tuple
 */

tuple ::= OPENING_CURLY EOL*
          containerArguments? EOL*
          CLOSING_CURLY
          { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Bit String
 */

bitString ::= OPENING_BIT EOL*
              (containerArguments EOL*)?
              CLOSING_BIT
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

accessExpression ::= atNumericOperation |
                     captureNumericOperation |
                     unaryNumericOperation |
                     anonymousFunction |
                     parentheticalStab |
                     numeric |
                     list |
                     map |
                     tuple |
                     bitString |
                     stringLine !KEYWORD_PAIR_COLON |
                     stringHeredoc |
                     charListLine !KEYWORD_PAIR_COLON |
                     charListHeredoc |
                     interpolatedCharListSigilLine |
                     interpolatedCharListSigilHeredoc |
                     interpolatedRegexHeredoc |
                     interpolatedSigilHeredoc |
                     interpolatedStringSigilHeredoc |
                     interpolatedWordsHeredoc |
                     interpolatedWordsLine |
                     interpolatedRegexLine |
                     interpolatedSigilLine |
                     interpolatedStringSigilLine |
                     literalCharListSigilLine |
                     literalCharListSigilHeredoc |
                     literalRegexHeredoc |
                     literalSigilHeredoc |
                     literalStringSigilHeredoc |
                     literalWordsHeredoc |
                     literalRegexLine |
                     literalSigilLine |
                     literalStringSigilLine |
                     literalWordsLine |
                     atomKeyword |
                     atom |
                     alias
                     {
                       implements = [
                         "org.elixir_lang.psi.MaybeModuleName"
                         "org.elixir_lang.psi.Quotable"
                       ]
                       methods = [
                         isModuleName
                         quote
                       ]
                     }

// keywords that map to atoms
atomKeyword ::= FALSE | NIL | TRUE
                { implements = "org.elixir_lang.psi.Quotable" methods = [quote] name = "false, nil, true" }

alias ::= ALIAS_TOKEN !KEYWORD_PAIR_COLON
          {
            implements = [
              "org.elixir_lang.psi.NamedElement"
              "org.elixir_lang.psi.QualifiableAlias"
              "org.elixir_lang.psi.Quotable"
            ]
            methods = [
              fullyQualifiedName
              getName
              getNameIdentifier
              getReference
              isModuleName
              processDeclarations
              quote
              setName
            ]
          }

/*
 *
 *
 * Unmatched Expressions
 *
 *
 */

/*
 * Capture Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50
 */

unmatchedCaptureNonNumericOperation ::= capturePrefixOperator !numeric unmatchedExpression

/*
 * In Match Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L51
 */

// implements and methods defined by "infix operations" section above
unmatchedInMatchOperation ::= unmatchedExpression inMatchInfixOperator unmatchedExpression

/*
 * When Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L52
 */

/* noParenthesesKeywords needs to be in a separate operation so that only unmatchedWhenNoParenthesesKeywordsOperation is a
   POSTFIX operation and unmatchedWhenOperation can remain a BINARY operation.  With
   `(noParenthesesKeywords | matchedExpression)` as the right operand, matchdWhenExpression was a POSTFIX operator,
   which caused the precedence for matchedInMatchOperand and matchedWhenOperation to be wrong as demonstrated in
   49ffef5a33ca1102213821efb4e2140f97622ca1 by
   org.elixir_lang.parser_definition.MatchedINMatchOperationParsingTestCase.testMatchedWhenOperation. */
unmatchedWhenNoParenthesesKeywordsOperation ::= unmatchedExpression whenInfixOperator noParenthesesKeywords
                                                { elementType = unmatchedWhenOperation rightAssociative = true }
// implements and methods defined by "infix operations" section above
unmatchedWhenOperation ::= unmatchedExpression whenInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Type Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L53
 */

// implements and methods defined by "infix operations" section above
unmatchedTypeOperation ::= unmatchedExpression typeInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Pipe Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L54
 */

// implements and methods defined by "infix operations" section above
unmatchedPipeOperation ::= unmatchedExpression pipeInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Match Operation - right-associative
 *
 * @see see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L56
 */


// implements and methods defined by "infix operations" section above
unmatchedMatchOperation ::= unmatchedExpression matchInfixOperator unmatchedExpression
                            { rightAssociative = true }

/*
 * Or Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L57
 */

// implements and methods defined by "infix operations" section above
unmatchedOrOperation ::= unmatchedExpression orInfixOperator unmatchedExpression

/*
 * And Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L58
 */

// implements and methods defined by "infix operations" section above
unmatchedAndOperation ::= unmatchedExpression andInfixOperator unmatchedExpression

/*
 * Comparison Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L59
 */

// implements and methods defined by "infix operations" section above
unmatchedComparisonOperation ::= unmatchedExpression comparisonInfixOperator unmatchedExpression

/*
 * Relational Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L60
 */

// implements and methods defined by "infix operations" section above
unmatchedRelationalOperation ::= unmatchedExpression relationalInfixOperator unmatchedExpression

/*
 * Arrow Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L61
 */

// implements and methods defined by "infix operations" section above
unmatchedArrowOperation ::= unmatchedExpression arrowInfixOperator unmatchedExpression

/*
 * In Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L62
 */

// implements defined by "in operations" section above
// methods defined by "infix operations" section above
unmatchedInOperation ::= unmatchedExpression inInfixOperator unmatchedExpression

/*
 * Three Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/3487d00ddb5e90c7cf0e65d03717903b9b27eafd/lib/elixir/src/elixir_parser.yrl#L67
 */
// implements and methods defined by "infix operations" section above
unmatchedThreeOperation ::= unmatchedExpression threeInfixOperator unmatchedExpression

/*
 * Two Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L63
 */

// implements and methods defined by "infix operations" section above
unmatchedTwoOperation ::= unmatchedExpression twoInfixOperator unmatchedExpression
                          { rightAssociative = true }

/*
 * Addition Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L64
 *
 */

// implements and methods defined by "infix operations" section above
unmatchedAdditionOperation ::= unmatchedExpression additionInfixOperator unmatchedExpression

/*
 * Multiplication Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65
 *
 */

// implements and methods defined by "infix operations" section above
unmatchedMultiplicationOperation ::= unmatchedExpression multiplicationInfixOperator unmatchedExpression

/*
 * Unary Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67
 *
 */

unmatchedUnaryNonNumericOperation ::= unaryPrefixOperator !numeric unmatchedExpression

/*
 * Dot Operations
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L561-L565
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

/*
 * Dot (Anonymous function) Call Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L403
 */

unmatchedDotCall ::= unmatchedExpression dotInfixOperator parenthesesArguments parenthesesArguments? doBlock?
                     {
                       implements = "org.elixir_lang.psi.DotCall<org.elixir_lang.psi.stub.UnmatchedDotCall>"
                       mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedDotCall>"
                       stubClass = "org.elixir_lang.psi.stub.UnmatchedDotCall"
                     }

/*
 * Qualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

unmatchedQualifiedNoParenthesesCall ::= unmatchedExpression dotInfixOperator relativeIdentifier noParenthesesOneArgument doBlock?
                                        {
                                          implements = [
                                            "org.elixir_lang.psi.QualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall>"
                                          ]
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall"
                                        }

/*
 * At Operation on Unqualified No Parentheses CALL
 *
 * Needed because matchedAtNonNumericOperation must be after *matchedQualified* and *matchedBracketOperation, but
 * *matchedUnqualifiedNoParenthesesCall needs to be an operand of At so that the entire call is an operand instead of
 * just the variable.
 */

atIdentifier ::= atPrefixOperator IDENTIFIER_TOKEN
                 { methods = [getReference] }
unmatchedAtUnqualifiedNoParenthesesCall ::= atIdentifier noParenthesesOneArgument doBlock?
                                            {
                                              implements = "org.elixir_lang.psi.AtUnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall>"
                                              mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall>"
                                              stubClass = "org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall"
                                            }

/*
 * Unqualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

unmatchedUnqualifiedNoParenthesesCall ::= identifier noParenthesesOneArgument doBlock?
                                          {
                                            implements = "org.elixir_lang.psi.UnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall>"
                                            methods = [
                                              canonicalName
                                              canonicalNameSet
                                              exportedArity
                                              exportedName
                                              functionName
                                              functionNameElement
                                              getDoBlock
                                              hasDoBlockOrKeyword
                                              isExported
                                              getName
                                              getNameIdentifier
                                              getPresentation
                                              getReference
                                              getStub
                                              getUseScope
                                              isCalling
                                              isCallingMacro
                                              moduleName
                                              primaryArguments
                                              primaryArity
                                              processDeclarations
                                              quote
                                              resolvedFinalArity
                                              resolvedFinalArityRange
                                              resolvedModuleName
                                              resolvedPrimaryArity
                                              resolvedSecondaryArity
                                              secondaryArguments
                                              secondaryArity
                                              setName
                                            ]
                                            mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall>"
                                            stubClass="org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall"
                                          }

/*
 * Bracket Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L238
 */

unmatchedBracketOperation ::= unmatchedExpression bracketArguments
                              { implements = "org.elixir_lang.psi.BracketOperation" methods = [quote] }

/*
 * Qualified Alias
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L388
 */

unmatchedQualifiedAlias ::= unmatchedExpression dotInfixOperator alias
                            {
                              implements = "org.elixir_lang.psi.QualifiedAlias"
                              methods = [
                                fullyQualifiedName
                                getName
                                getNameIdentifier
                                getReference
                                isModuleName
                                processDeclarations
                                quote
                                setName
                              ]
                            }

/*
 * Qualified Multiple Alias
 *
 * See https://github.com/elixir-lang/elixir/pull/3666
 */
unmatchedQualifiedMultipleAliases ::= unmatchedExpression dotInfixOperator multipleAliases

/*
 * Qualified Identifier Bracket Operation
 */

unmatchedQualifiedBracketOperation ::= unmatchedExpression dotInfixOperator relativeIdentifier CALL bracketArguments

/*
 * Qualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

unmatchedQualifiedParenthesesCall ::= unmatchedExpression dotInfixOperator relativeIdentifier matchedParenthesesArguments doBlock?
                                      {
                                        implements = "org.elixir_lang.psi.QualifiedParenthesesCall<org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall>"
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall"
                                      }

/*
 * Qualified Call with No Arguments - neither parenthes nor no parentheses
 */

unmatchedQualifiedNoArgumentsCall ::= unmatchedExpression dotInfixOperator relativeIdentifier !CALL doBlock?
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.QualifiedNoArgumentsCall<org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall>"
                                        stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall"
                                      }

/*
 * At Unqualified Bracket Operation
 *
 * Needed so that At consumes Unqualified identifier, but brackets consume both of them.
 */

unmatchedAtUnqualifiedBracketOperation ::= atPrefixOperator IDENTIFIER_TOKEN CALL bracketArguments
                                           { implements = "org.elixir_lang.psi.AtUnqualifiedBracketOperation" methods = [quote] }

/*
 * Unqualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

unmatchedUnqualifiedParenthesesCall ::= identifier matchedParenthesesArguments doBlock?
                                        {
                                          implements = "org.elixir_lang.psi.UnqualifiedParenthesesCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall>"
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall"
                                        }

/*
 * At Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

unmatchedAtNonNumericOperation ::= atPrefixOperator !numeric unmatchedExpression

/*
 * Unqualified Bracket Operation
 */

unmatchedUnqualifiedBracketOperation ::= identifier CALL bracketArguments
                                         {
                                           implements = "org.elixir_lang.psi.UnqualifiedBracketOperation"
                                           methods = [quote]
                                         }

/*
 * Unqualified No Arguments Call
 */

unmatchedUnqualifiedNoArgumentsCall ::= identifier !KEYWORD_PAIR_COLON doBlock?
                                        {
                                          implements = "org.elixir_lang.psi.UnqualifiedNoArgumentsCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall>"
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall"
                                        }

unmatchedAccessExpression ::= accessExpression
                              { elementType = accessExpression }

/*
 *
 * Do Block
 *
 */

/*
 * Block Identifier
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L946
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L977-L981
 */
blockIdentifier ::= AFTER | CATCH | ELSE | RESCUE
                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L313-L314
blockItem ::= blockIdentifier endOfExpression? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L290-L291
              (stab endOfExpression?)? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L313
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L316-L317
blockList ::= blockItem+
              { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L272-L275
doBlock ::= EOL* DO endOfExpression?
            stab? endOfExpression? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L273
            blockList? endOfExpression? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L274
            END
            {
              implements = "org.elixir_lang.psi.QuotableArguments"
              methods = [quoteArguments]
              pin = DO
            }

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L143-L148
unmatchedExpression ::= unmatchedCaptureNonNumericOperation |
                        unmatchedInMatchOperation |
                        /* noParenthesesKeywords needs to be first as matchedExpression will match due to the error
                         handling built into the Pratt parser. */
                        unmatchedWhenNoParenthesesKeywordsOperation |
                        unmatchedWhenOperation |
                        unmatchedTypeOperation |
                        unmatchedPipeOperation |
                        unmatchedMatchOperation |
                        unmatchedOrOperation |
                        unmatchedAndOperation |
                        unmatchedComparisonOperation |
                        unmatchedRelationalOperation |
                        unmatchedArrowOperation |
                        unmatchedInOperation |
                        unmatchedThreeOperation |
                        unmatchedTwoOperation |
                        unmatchedAdditionOperation |
                        unmatchedMultiplicationOperation |
                        unmatchedUnaryNonNumericOperation |
                        unmatchedDotCall |
                        // NoParentheses before unmatchedBracketOperation because brackets only make sense after parentheses.
                        unmatchedQualifiedNoParenthesesCall |
                        unmatchedAtUnqualifiedNoParenthesesCall |
                        unmatchedUnqualifiedNoParenthesesCall |
                        unmatchedBracketOperation |
                        unmatchedQualifiedAlias |
                        unmatchedQualifiedMultipleAliases |
                        unmatchedQualifiedBracketOperation |
                        unmatchedQualifiedParenthesesCall |
                        unmatchedQualifiedNoArgumentsCall |
                        unmatchedAtUnqualifiedBracketOperation |
                        unmatchedAtNonNumericOperation | // after unmatchedQualified because @ binds only before `.`
                        unmatchedUnqualifiedParenthesesCall |
                        unmatchedUnqualifiedBracketOperation |
                        unmatchedUnqualifiedNoArgumentsCall |
                        unmatchedAccessExpression

/*
 *
 *
 * Whole Numbers
 *
 *
 *
 */

decimalDigits ::= INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS
                  { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
decimalWholeNumber ::= decimalDigits (DECIMAL_SEPARATOR? decimalDigits)*
                        {
                          implements = "org.elixir_lang.psi.WholeNumber"
                          methods = [
                            base
                            digitsList
                            quote
                          ]
                        }

/*
 *
 * Base (Non-Decimal) Whole Numbers
 *
 */

/*
 * Binary (2)
 */

binaryDigits ::= INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS
                 { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) binaryDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Hexadecimal (16)
 */

hexadecimalDigits ::= INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) hexadecimalDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin = 2
                           }

/*
 * Octal (8)
 */

octalDigits ::= INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS
                { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE octalDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Unknown (1-36)
 */

unknownBaseDigits ::= INVALID_UNKNOWN_BASE_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE unknownBaseDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin=2
                           }

/*
 *
 *
 * In alphabetical order
 *
 *
 */

atom ::= COLON (ATOM_FRAGMENT | quote)
         {
           implements = [
             "com.intellij.psi.NavigatablePsiElement"
             "org.elixir_lang.psi.Quotable"
           ]
           methods = [quote]
         }

private infixComma ::= COMMA EOL*

charToken ::= CHAR_TOKENIZER (CHAR_LIST_FRAGMENT | quoteEscapeSequence)
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private containerExpression ::= emptyParentheses |
                                unmatchedExpression

decimalFloat ::= decimalFloatIntegral DECIMAL_MARK decimalFloatFractional (EXPONENT_MARK decimalFloatExponent)?
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
decimalFloatExponent ::= decimalFloatExponentSign decimalWholeNumber
decimalFloatExponentSign ::= DUAL_OPERATOR?
decimalFloatFractional ::= decimalWholeNumber
decimalFloatIntegral ::= decimalWholeNumber

/*
 *
 * Escape Sequences
 *
 */

/*
 * Shared subrules
 */

hexadecimalEscapePrefix ::= ESCAPE (HEXADECIMAL_WHOLE_NUMBER_BASE | UNICODE_ESCAPE_CHARACTER)
enclosedHexadecimalEscapeSequence ::= OPENING_CURLY VALID_HEXADECIMAL_DIGITS CLOSING_CURLY
                                      { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] pin = 1 }
openHexadecimalEscapeSequence ::= VALID_HEXADECIMAL_DIGITS
                                  { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] }
escapedCharacter ::= ESCAPE ESCAPED_CHARACTER_TOKEN
                     { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] pin = 1 }
escapedEOL ::= ESCAPE EOL
               { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] }

/*
 * Quotes (charListHeredoc, charListLine, stringHeredoc, stringLine)
 */

private quoteEscapeSequence ::= quoteHexadecimalEscapeSequence |
                                escapedEOL |
                                /* Must be last so that ESCAPE ('\') can be pinned in escapedCharacter without excluding
                                   ("\x") in hexadecimalEscapeSequence  */
                                escapedCharacter
quoteHexadecimalEscapeSequence ::= hexadecimalEscapePrefix (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence)
                                   {
                                     implements = "org.elixir_lang.psi.EscapeSequence"
                                     methods = [codePoint]
                                     pin = 1
                                   }

/*
 * Keywords
 */

keywordKey ::= AFTER |
               ALIAS_TOKEN |
               AND_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               CATCH |
               COMPARISON_OPERATOR |
               DO |
               DUAL_OPERATOR |
               ELSE |
               IDENTIFIER_TOKEN |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MULTIPLICATION_OPERATOR |
               NIL |
               NOT_OPERATOR |
               OR_OPERATOR |
               PIPE_OPERATOR |
               RESCUE |
               RELATIONAL_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               THREE_OPERATOR |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
               {
                 implements = [
                   "org.elixir_lang.psi.NamedElement"
                   "org.elixir_lang.psi.Quotable"
                 ]
                 methods = [
                   getName
                   getNameIdentifier
                   quote
                   setName
                 ]
               }
// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L499
private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*

/* @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L499 */
keywordPair ::=  keywordKeyColonEOL containerExpression
                 {
                   implements = "org.elixir_lang.psi.QuotableKeywordPair"
                   methods = [
                     getKeywordKey
                     getKeywordValue
                     quote
                   ]
                 }
/* @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L500
   @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L502-L503 */
keywords ::= keywordPair (infixComma keywordPair)* COMMA?
             { implements = "org.elixir_lang.psi.QuotableKeywordList" methods = [quotableKeywordPairList quote] }

/*
 * Sigil
 */

private sigilEscapeSequence ::= sigilHexadecimalEscapeSequence |
                                hexadecimalEscapePrefix |
                                escapedEOL |
                                /* Must be last so that ESCAPE ('\') can be pinned in escapedCharacter without excluding
                                   ("\x") or ("\\u") in hexadecimalEscapeSequence  */
                                escapedCharacter
// Does not pin so that escapePrefix can match separately as `\x` and `\u` is valid for sigils
sigilHexadecimalEscapeSequence ::= hexadecimalEscapePrefix (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence)
                                   {
                                     implements = "org.elixir_lang.psi.EscapeSequence"
                                     methods = [codePoint]
                                   }

emptyParentheses ::= OPENING_PARENTHESIS EOL* CLOSING_PARENTHESIS
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
interpolation ::= INTERPOLATION_START elixirFile INTERPOLATION_END
                  { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * List
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L476-L484
 */

private containerArgumentsBase ::= containerExpression (infixComma containerExpression)*
private containerArguments ::= containerArgumentsBase (infixComma keywords | infixComma)?

private listArguments ::= keywords |
                          containerArguments

list ::= OPENING_BRACKET EOL*
         listArguments? EOL*
         CLOSING_BRACKET
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/* elixir_tokenizer.erl converts CHAR_TOKEN_TOKENs to their number representation, so `number` in elixir_parser.yrl matches
   Elixir.flex's CHAR_TOKEN_TOKEN and all the different base number rules. */
private numeric ::= charToken |
                    binaryWholeNumber |
                    // decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
                    decimalFloat |
                    decimalWholeNumber |
                    hexadecimalWholeNumber |
                    octalWholeNumber |
                    unknownBaseWholeNumber

private quote ::= (charListLine | stringLine)
